'use strict';

var vue = require('vue');
var helpers = require('./helpers.js');
var config = require('./config.js');
var plugins$1 = require('./plugins-194ea16f.js');
var Icon = require('./Icon-e1b4d3c8.js');
var FormElementMixin = require('./FormElementMixin-4321a3d6.js');
var Input = require('./Input-961b6450.js');
var MatchMediaMixin = require('./MatchMediaMixin-72cab4f9.js');
var DropdownItem = require('./DropdownItem-a89240e8.js');
var Field = require('./Field-1add5ace.js');
var Select = require('./Select-f38437a8.js');

var script = vue.defineComponent({
    name: 'ODatepickerTableRow',
    mixins: [plugins$1.BaseComponentMixin],
    configField: 'datepicker',
    inject: {
        $datepicker: { from: '$datepicker', default: false }
    },
    emits: ['select', 'rangeHoverEndDate', 'change-focus'],
    props: {
        selectedDate: {
            type: [Date, Array]
        },
        hoveredDateRange: Array,
        day: {
            type: Number
        },
        week: {
            type: Array,
            required: true
        },
        month: {
            type: Number,
            required: true
        },
        showWeekNumber: Boolean,
        minDate: Date,
        maxDate: Date,
        disabled: Boolean,
        unselectableDates: Array,
        unselectableDaysOfWeek: Array,
        selectableDates: Array,
        events: Array,
        indicators: String,
        dateCreator: Function,
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        weekNumberClickable: Boolean,
        range: Boolean,
        multiple: Boolean,
        rulesForFirstWeek: Number,
        firstDayOfWeek: Number,
        tableRowClass: [String, Function, Array],
        tableCellClass: [String, Function, Array],
        tableCellSelectedClass: [String, Function, Array],
        tableCellFirstSelectedClass: [String, Function, Array],
        tableCellWithinSelectedClass: [String, Function, Array],
        tableCellLastSelectedClass: [String, Function, Array],
        tableCellFirstHoveredClass: [String, Function, Array],
        tableCellInvisibleClass: [String, Function, Array],
        tableCellWithinHoveredClass: [String, Function, Array],
        tableCellLastHoveredClass: [String, Function, Array],
        tableCellTodayClass: [String, Function, Array],
        tableCellSelectableClass: [String, Function, Array],
        tableCellUnselectableClass: [String, Function, Array],
        tableCellNearbyClass: [String, Function, Array],
        tableCellEventsClass: [String, Function, Array],
        tableEventClass: [String, Function, Array],
        tableEventIndicatorsClass: [String, Function, Array],
        tableEventsClass: [String, Function, Array],
        tableEventVariantClass: [String, Function, Array],
    },
    computed: {
        tableRowClasses() {
            return [
                this.computedClass('tableRowClass', 'o-dpck__table__row'),
            ];
        },
        tableCellClasses() {
            return [
                this.computedClass('tableCellClass', 'o-dpck__table__cell'),
            ];
        },
        tableEventsClasses() {
            return [
                this.computedClass('tableEventsClass', 'o-dpck__table__events'),
            ];
        },
        hasEvents() {
            return this.events && this.events.length;
        }
    },
    watch: {
        day(day) {
            const refName = `day-${this.month}-${day}`;
            this.$nextTick(() => {
                if (this.$refs[refName] && this.$refs[refName].length > 0) {
                    if (this.$refs[refName][0]) {
                        this.$refs[refName][0].focus();
                    }
                }
            }); // $nextTick needed when month is changed
        }
    },
    methods: {
        firstWeekOffset(year, dow, doy) {
            // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            const fwd = 7 + dow - doy;
            // first-week day local weekday -- which local weekday is fwd
            const firstJanuary = new Date(year, 0, fwd);
            const fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
            return -fwdlw + fwd - 1;
        },
        daysInYear(year) {
            return this.isLeapYear(year) ? 366 : 365;
        },
        isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        },
        getSetDayOfYear(input) {
            return Math.round((input.getTime() - new Date(input.getFullYear(), 0, 1).getTime()) / 864e5) + 1;
        },
        weeksInYear(year, dow, doy) {
            const weekOffset = this.firstWeekOffset(year, dow, doy);
            const weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy);
            return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        },
        getWeekNumber(mom) {
            const dow = this.firstDayOfWeek; // first day of week
            // Rules for the first week : 1 for the 1st January, 4 for the 4th January
            const doy = this.rulesForFirstWeek;
            const weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy);
            const week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1;
            let resWeek;
            let resYear;
            if (week < 1) {
                resYear = mom.getFullYear() - 1;
                resWeek = week + this.weeksInYear(resYear, dow, doy);
            }
            else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {
                resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy);
                resYear = mom.getFullYear() + 1;
            }
            else {
                resYear = mom.getFullYear();
                resWeek = week;
            }
            return resWeek;
        },
        clickWeekNumber(week) {
            if (this.weekNumberClickable) {
                this.$datepicker.$emit('week-number-click', week);
            }
        },
        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate(day) {
            const validity = [];
            if (this.minDate) {
                validity.push(day >= this.minDate);
            }
            if (this.maxDate) {
                validity.push(day <= this.maxDate);
            }
            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
                validity.push(day.getMonth() === this.month);
            }
            if (this.selectableDates) {
                for (let i = 0; i < this.selectableDates.length; i++) {
                    const enabledDate = this.selectableDates[i];
                    if (day.getDate() === enabledDate.getDate() &&
                        day.getFullYear() === enabledDate.getFullYear() &&
                        day.getMonth() === enabledDate.getMonth()) {
                        return true;
                    }
                    else {
                        validity.push(false);
                    }
                }
            }
            if (this.unselectableDates) {
                for (let i = 0; i < this.unselectableDates.length; i++) {
                    const disabledDate = this.unselectableDates[i];
                    validity.push(day.getDate() !== disabledDate.getDate() ||
                        day.getFullYear() !== disabledDate.getFullYear() ||
                        day.getMonth() !== disabledDate.getMonth());
                }
            }
            if (this.unselectableDaysOfWeek) {
                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
                    const dayOfWeek = this.unselectableDaysOfWeek[i];
                    validity.push(day.getDay() !== dayOfWeek);
                }
            }
            return validity.indexOf(false) < 0;
        },
        /*
        * Emit select event with chosen date as payload
        */
        emitChosenDate(day) {
            if (this.disabled)
                return;
            if (this.selectableDate(day)) {
                this.$emit('select', day);
            }
        },
        eventsDateMatch(day) {
            if (!this.events || !this.events.length)
                return false;
            const dayEvents = [];
            for (let i = 0; i < this.events.length; i++) {
                if (this.events[i].date.getDay() === day.getDay()) {
                    dayEvents.push(this.events[i]);
                }
            }
            if (!dayEvents.length) {
                return false;
            }
            return dayEvents;
        },
        /*
        * Build cellClasses for cell using validations
        */
        cellClasses(day) {
            function dateMatch(dateOne, dateTwo, multiple = false) {
                // if either date is null or undefined, return false
                // if using multiple flag, return false
                if (!dateOne || !dateTwo || multiple) {
                    return false;
                }
                if (Array.isArray(dateTwo)) {
                    return dateTwo.some((date) => (dateOne.getDate() === date.getDate() &&
                        dateOne.getFullYear() === date.getFullYear() &&
                        dateOne.getMonth() === date.getMonth()));
                }
                return (dateOne.getDate() === dateTwo.getDate() &&
                    dateOne.getFullYear() === dateTwo.getFullYear() &&
                    dateOne.getMonth() === dateTwo.getMonth());
            }
            function dateWithin(dateOne, dates, multiple = false) {
                if (!Array.isArray(dates) || multiple) {
                    return false;
                }
                return dateOne > dates[0] && dateOne < dates[1];
            }
            return [
                ...this.tableCellClasses,
                {
                    [this.computedClass('tableCellSelectedClass', 'o-dpck__table__cell--selected')]: dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple)
                },
                {
                    [this.computedClass('tableCellFirstSelectedClass', 'o-dpck__table__cell--first-selected')]: dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[0], this.multiple),
                },
                {
                    [this.computedClass('tableCellWithinSelectedClass', 'o-dpck__table__cell--within-selected')]: dateWithin(day, this.selectedDate, this.multiple)
                },
                {
                    [this.computedClass('tableCellLastSelectedClass', 'o-dpck__table__cell--last-selected')]: dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[1], this.multiple),
                },
                {
                    [this.computedClass('tableCellFirstHoveredClass', 'o-dpck__table__cell--first-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0]),
                },
                {
                    [this.computedClass('tableCellWithinHoveredClass', 'o-dpck__table__cell--within-hovered')]: dateWithin(day, this.hoveredDateRange)
                },
                {
                    [this.computedClass('tableCellLastHoveredClass', 'o-dpck__table__cell--last-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1])
                },
                {
                    [this.computedClass('tableCellTodayClass', 'o-dpck__table__cell--today')]: dateMatch(day, this.dateCreator())
                },
                {
                    [this.computedClass('tableCellSelectableClass', 'o-dpck__table__cell--selectable')]: this.selectableDate(day) && !this.disabled
                },
                {
                    [this.computedClass('tableCellUnselectableClass', 'o-dpck__table__cell--unselectable')]: !this.selectableDate(day) || this.disabled
                },
                {
                    [this.computedClass('tableCellInvisibleClass', 'o-dpck__table__cell--invisible')]: !this.nearbyMonthDays && day.getMonth() !== this.month
                },
                {
                    [this.computedClass('tableCellNearbyClass', 'o-dpck__table__cell--nearby')]: this.nearbySelectableMonthDays && day.getMonth() !== this.month
                },
                {
                    [this.computedClass('tableCellEventsClass', 'o-dpck__table__cell--events')]: this.hasEvents
                },
                {
                    [this.computedClass('tableCellTodayClass', 'o-dpck__table__cell--today')]: dateMatch(day, this.dateCreator())
                }
            ];
        },
        eventClasses(event) {
            return [
                this.computedClass('tableEventClass', 'o-dpck__table__event'),
                { [this.computedClass('tableEventVariantClass', 'o-dpck__table__event--', event.type)]: event.type },
                { [this.computedClass('tableEventIndicatorsClass', 'o-dpck__table__event--', this.indicators)]: this.indicators }
            ];
        },
        setRangeHoverEndDate(day) {
            if (this.range) {
                this.$emit('rangeHoverEndDate', day);
            }
        },
        manageKeydown(event, weekDay) {
            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
            const { key } = event;
            let preventDefault = true;
            switch (key) {
                case 'Tab': {
                    preventDefault = false;
                    break;
                }
                case ' ':
                case 'Space':
                case 'Spacebar':
                case 'Enter': {
                    this.emitChosenDate(weekDay);
                    break;
                }
                case 'ArrowLeft':
                case 'Left': {
                    this.changeFocus(weekDay, -1);
                    break;
                }
                case 'ArrowRight':
                case 'Right': {
                    this.changeFocus(weekDay, 1);
                    break;
                }
                case 'ArrowUp':
                case 'Up': {
                    this.changeFocus(weekDay, -7);
                    break;
                }
                case 'ArrowDown':
                case 'Down': {
                    this.changeFocus(weekDay, 7);
                    break;
                }
            }
            if (preventDefault) {
                event.preventDefault();
            }
        },
        changeFocus(day, inc) {
            const nextDay = new Date(day.getTime());
            nextDay.setDate(day.getDate() + inc);
            while ((!this.minDate || nextDay > this.minDate) &&
                (!this.maxDate || nextDay < this.maxDate) &&
                !this.selectableDate(nextDay)) {
                nextDay.setDate(day.getDate() + Math.sign(inc));
            }
            this.setRangeHoverEndDate(nextDay);
            this.$emit('change-focus', nextDay);
        }
    }
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("div", {
    class: _ctx.tableRowClasses
  }, [_ctx.showWeekNumber ? (vue.openBlock(), vue.createBlock("a", {
    key: 0,
    class: _ctx.tableCellClasses,
    style: {
      'cursor: pointer': _ctx.weekNumberClickable
    },
    onClick: _cache[1] || (_cache[1] = vue.withModifiers($event => _ctx.clickWeekNumber(_ctx.getWeekNumber(_ctx.week[6])), ["prevent"]))
  }, [vue.createVNode("span", null, vue.toDisplayString(_ctx.getWeekNumber(_ctx.week[6])), 1
  /* TEXT */
  )], 6
  /* CLASS, STYLE */
  )) : vue.createCommentVNode("v-if", true), (vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.week, (weekDay, index) => {
    return vue.openBlock(), vue.createBlock(vue.Fragment, {
      key: index
    }, [_ctx.selectableDate(weekDay) && !_ctx.disabled ? (vue.openBlock(), vue.createBlock("a", {
      key: 0,
      ref: `day-${weekDay.getMonth()}-${weekDay.getDate()}`,
      class: _ctx.cellClasses(weekDay),
      role: "button",
      href: "#",
      disabled: _ctx.disabled,
      onClick: vue.withModifiers($event => _ctx.emitChosenDate(weekDay), ["prevent"]),
      onMouseenter: $event => _ctx.setRangeHoverEndDate(weekDay),
      onKeydown: $event => _ctx.manageKeydown($event, weekDay),
      tabindex: _ctx.day === weekDay.getDate() && _ctx.month === weekDay.getMonth() ? null : -1
    }, [vue.createVNode("span", null, vue.toDisplayString(weekDay.getDate()), 1
    /* TEXT */
    ), _ctx.eventsDateMatch(weekDay) ? (vue.openBlock(), vue.createBlock("div", {
      key: 0,
      class: _ctx.tableEventsClasses
    }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.eventsDateMatch(weekDay), (event, index) => {
      return vue.openBlock(), vue.createBlock("div", {
        class: _ctx.eventClasses(event),
        key: index
      }, null, 2
      /* CLASS */
      );
    }), 128
    /* KEYED_FRAGMENT */
    ))], 2
    /* CLASS */
    )) : vue.createCommentVNode("v-if", true)], 42
    /* CLASS, PROPS, HYDRATE_EVENTS */
    , ["disabled", "onClick", "onMouseenter", "onKeydown", "tabindex"])) : (vue.openBlock(), vue.createBlock("div", {
      key: index,
      class: _ctx.cellClasses(weekDay)
    }, [vue.createVNode("span", null, vue.toDisplayString(weekDay.getDate()), 1
    /* TEXT */
    )], 2
    /* CLASS */
    ))], 64
    /* STABLE_FRAGMENT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  );
}

script.render = render;
script.__file = "src/components/datepicker/DatepickerTableRow.vue";

var script$1 = vue.defineComponent({
    name: 'ODatepickerTable',
    mixins: [plugins$1.BaseComponentMixin],
    configField: 'datepicker',
    components: {
        [script.name]: script
    },
    emits: ['update:modelValue', 'range-start', 'range-end', 'update:focused'],
    props: {
        modelValue: {
            type: [Date, Array]
        },
        dayNames: Array,
        monthNames: Array,
        firstDayOfWeek: Number,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: Array,
        unselectableDaysOfWeek: Array,
        selectableDates: Array,
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        showWeekNumber: Boolean,
        weekNumberClickable: Boolean,
        rulesForFirstWeek: Number,
        range: Boolean,
        multiple: Boolean,
        tableClass: [String, Function, Array],
        tableHeadClass: [String, Function, Array],
        tableHeadCellClass: [String, Function, Array],
        tableBodyClass: [String, Function, Array],
        tableRowClass: [String, Function, Array],
        tableCellClass: [String, Function, Array],
        tableCellSelectedClass: [String, Function, Array],
        tableCellFirstSelectedClass: [String, Function, Array],
        tableCellInvisibleClass: [String, Function, Array],
        tableCellWithinSelectedClass: [String, Function, Array],
        tableCellLastSelectedClass: [String, Function, Array],
        tableCellFirstHoveredClass: [String, Function, Array],
        tableCellWithinHoveredClass: [String, Function, Array],
        tableCellLastHoveredClass: [String, Function, Array],
        tableCellTodayClass: [String, Function, Array],
        tableCellSelectableClass: [String, Function, Array],
        tableCellUnselectableClass: [String, Function, Array],
        tableCellNearbyClass: [String, Function, Array],
        tableCellEventsClass: [String, Function, Array],
        tableEventClass: [String, Function, Array],
        tableEventIndicatorsClass: [String, Function, Array],
        tableEventsClass: [String, Function, Array],
        tableEventVariantClass: [String, Function, Array],
    },
    data() {
        return {
            selectedBeginDate: undefined,
            selectedEndDate: undefined,
            hoveredEndDate: undefined
        };
    },
    computed: {
        tableClasses() {
            return [
                this.computedClass('tableClass', 'o-dpck__table')
            ];
        },
        tableHeadClasses() {
            return [
                this.computedClass('tableHeadClass', 'o-dpck__table__head')
            ];
        },
        tableHeadCellClasses() {
            return [
                this.computedClass('tableHeadCellClass', 'o-dpck__table__head-cell'),
                ...this.tableCellClasses
            ];
        },
        tableBodyClasses() {
            return [
                this.computedClass('tableBodyClass', 'o-dpck__table__body')
            ];
        },
        tableCellClasses() {
            return [
                this.computedClass('tableCellClass', 'o-dpck__table__cell'),
            ];
        },
        visibleDayNames() {
            const visibleDayNames = [];
            let index = this.firstDayOfWeek;
            while (visibleDayNames.length < this.dayNames.length) {
                const currentDayName = this.dayNames[(index % this.dayNames.length)];
                visibleDayNames.push(currentDayName);
                index++;
            }
            if (this.showWeekNumber)
                visibleDayNames.unshift('');
            return visibleDayNames;
        },
        /*
        * Return array of all events in the specified month
        */
        eventsInThisMonth() {
            if (!this.events)
                return [];
            const monthEvents = [];
            for (let i = 0; i < this.events.length; i++) {
                let event = this.events[i];
                if (!Object.prototype.hasOwnProperty.call(event, 'date')) {
                    event = { date: event };
                }
                if (event.date.getMonth() === this.focused.month &&
                    event.date.getFullYear() === this.focused.year) {
                    monthEvents.push(event);
                }
            }
            return monthEvents;
        },
        /*
        * Return array of all weeks in the specified month
        */
        weeksInThisMonth() {
            this.validateFocusedDay();
            const month = this.focused.month;
            const year = this.focused.year;
            const weeksInThisMonth = [];
            let startingDay = 1;
            while (weeksInThisMonth.length < 6) {
                const newWeek = this.weekBuilder(startingDay, month, year);
                weeksInThisMonth.push(newWeek);
                startingDay += 7;
            }
            return weeksInThisMonth;
        },
        hoveredDateRange() {
            if (!this.range) {
                return [];
            }
            if (!isNaN(this.selectedEndDate)) {
                return [];
            }
            if (this.hoveredEndDate < this.selectedBeginDate) {
                return [this.hoveredEndDate, this.selectedBeginDate].filter(d => d !== undefined);
            }
            return [this.selectedBeginDate, this.hoveredEndDate].filter(d => d !== undefined);
        }
    },
    methods: {
        /*
        * Emit input event with selected date as payload for v-model in parent
        */
        updateSelectedDate(date) {
            if (!this.range && !this.multiple) {
                this.$emit('update:modelValue', date);
            }
            else if (this.range) {
                this.handleSelectRangeDate(date);
            }
            else if (this.multiple) {
                this.handleSelectMultipleDates(date);
            }
        },
        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate(date) {
            if (this.selectedBeginDate && this.selectedEndDate) {
                this.selectedBeginDate = date;
                this.selectedEndDate = undefined;
                this.$emit('range-start', date);
            }
            else if (this.selectedBeginDate && !this.selectedEndDate) {
                if (this.selectedBeginDate > date) {
                    this.selectedEndDate = this.selectedBeginDate;
                    this.selectedBeginDate = date;
                }
                else {
                    this.selectedEndDate = date;
                }
                this.$emit('range-end', date);
                this.$emit('update:modelValue', [this.selectedBeginDate, this.selectedEndDate]);
            }
            else {
                this.selectedBeginDate = date;
                this.$emit('range-start', date);
            }
        },
        /*
        * If selected date already exists list of selected dates, remove it from the list
        * Otherwise, add date to list of selected dates
        */
        handleSelectMultipleDates(date) {
            let multipleSelectedDates = this.modelValue;
            const multipleSelect = multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() === date.getDate() &&
                selectedDate.getFullYear() === date.getFullYear() &&
                selectedDate.getMonth() === date.getMonth());
            if (multipleSelect.length) {
                multipleSelectedDates = multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() !== date.getDate() ||
                    selectedDate.getFullYear() !== date.getFullYear() ||
                    selectedDate.getMonth() !== date.getMonth());
            }
            else {
                multipleSelectedDates = [...multipleSelectedDates, date];
            }
            this.$emit('update:modelValue', multipleSelectedDates);
        },
        /*
         * Return array of all days in the week that the startingDate is within
         */
        weekBuilder(startingDate, month, year) {
            const thisMonth = new Date(year, month);
            const thisWeek = [];
            const dayOfWeek = new Date(year, month, startingDate).getDay();
            const end = dayOfWeek >= this.firstDayOfWeek
                ? (dayOfWeek - this.firstDayOfWeek)
                : ((7 - this.firstDayOfWeek) + dayOfWeek);
            let daysAgo = 1;
            for (let i = 0; i < end; i++) {
                thisWeek.unshift(new Date(thisMonth.getFullYear(), thisMonth.getMonth(), startingDate - daysAgo));
                daysAgo++;
            }
            thisWeek.push(new Date(year, month, startingDate));
            let daysForward = 1;
            while (thisWeek.length < 7) {
                thisWeek.push(new Date(year, month, startingDate + daysForward));
                daysForward++;
            }
            return thisWeek;
        },
        validateFocusedDay() {
            const focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day);
            if (this.selectableDate(focusedDate))
                return;
            let day = 0;
            // Number of days in the current month
            const monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate();
            let firstFocusable = null;
            while (!firstFocusable && ++day < monthDays) {
                const date = new Date(this.focused.year, this.focused.month, day);
                if (this.selectableDate(date)) {
                    firstFocusable = focusedDate;
                    const focused = {
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear()
                    };
                    this.$emit('update:focused', focused);
                }
            }
        },
        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate(day) {
            const validity = [];
            if (this.minDate) {
                validity.push(day >= this.minDate);
            }
            if (this.maxDate) {
                validity.push(day <= this.maxDate);
            }
            if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
                validity.push(day.getMonth() === this.focused.month);
            }
            if (this.selectableDates) {
                for (let i = 0; i < this.selectableDates.length; i++) {
                    const enabledDate = this.selectableDates[i];
                    if (day.getDate() === enabledDate.getDate() &&
                        day.getFullYear() === enabledDate.getFullYear() &&
                        day.getMonth() === enabledDate.getMonth()) {
                        return true;
                    }
                    else {
                        validity.push(false);
                    }
                }
            }
            if (this.unselectableDates) {
                for (let i = 0; i < this.unselectableDates.length; i++) {
                    const disabledDate = this.unselectableDates[i];
                    validity.push(day.getDate() !== disabledDate.getDate() ||
                        day.getFullYear() !== disabledDate.getFullYear() ||
                        day.getMonth() !== disabledDate.getMonth());
                }
            }
            if (this.unselectableDaysOfWeek) {
                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
                    const dayOfWeek = this.unselectableDaysOfWeek[i];
                    validity.push(day.getDay() !== dayOfWeek);
                }
            }
            return validity.indexOf(false) < 0;
        },
        eventsInThisWeek(week) {
            return this.eventsInThisMonth.filter((event) => {
                const stripped = new Date(Date.parse(event.date));
                stripped.setHours(0, 0, 0, 0);
                const timed = stripped.getTime();
                return week.some((weekDate) => weekDate.getTime() === timed);
            });
        },
        setRangeHoverEndDate(day) {
            this.hoveredEndDate = day;
        },
        changeFocus(day) {
            const focused = {
                day: day.getDate(),
                month: day.getMonth(),
                year: day.getFullYear()
            };
            this.$emit('update:focused', focused);
        }
    }
});

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_datepicker_table_row = vue.resolveComponent("o-datepicker-table-row");

  return vue.openBlock(), vue.createBlock("section", {
    class: _ctx.tableClasses
  }, [vue.createVNode("header", {
    class: _ctx.tableHeadClasses
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.visibleDayNames, (day, index) => {
    return vue.openBlock(), vue.createBlock("div", {
      key: index,
      class: _ctx.tableHeadCellClasses
    }, [vue.createVNode("span", null, vue.toDisplayString(day), 1
    /* TEXT */
    )], 2
    /* CLASS */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  ), vue.createVNode("div", {
    class: _ctx.tableBodyClasses
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.weeksInThisMonth, (week, index) => {
    return vue.openBlock(), vue.createBlock(_component_o_datepicker_table_row, {
      key: index,
      "selected-date": _ctx.modelValue,
      day: _ctx.focused.day,
      week: week,
      month: _ctx.focused.month,
      "min-date": _ctx.minDate,
      "max-date": _ctx.maxDate,
      disabled: _ctx.disabled,
      "unselectable-dates": _ctx.unselectableDates,
      "unselectable-days-of-week": _ctx.unselectableDaysOfWeek,
      "selectable-dates": _ctx.selectableDates,
      events: _ctx.eventsInThisWeek(week),
      indicators: _ctx.indicators,
      "date-creator": _ctx.dateCreator,
      "nearby-month-days": _ctx.nearbyMonthDays,
      "nearby-selectable-month-days": _ctx.nearbySelectableMonthDays,
      "show-week-number": _ctx.showWeekNumber,
      "week-number-clickable": _ctx.weekNumberClickable,
      "first-day-of-week": _ctx.firstDayOfWeek,
      "rules-for-first-week": _ctx.rulesForFirstWeek,
      range: _ctx.range,
      "hovered-date-range": _ctx.hoveredDateRange,
      multiple: _ctx.multiple,
      "table-row-class": _ctx.tableRowClass,
      "table-cell-class": _ctx.tableCellClass,
      "table-cell-selected-class": _ctx.tableCellSelectedClass,
      "table-cell-first-selected-class": _ctx.tableCellFirstSelectedClass,
      "table-cell-invisible-class": _ctx.tableCellInvisibleClass,
      "table-cell-within-selected-class": _ctx.tableCellWithinSelectedClass,
      "table-cell-last-selected-class": _ctx.tableCellLastSelectedClass,
      "table-cell-first-hovered-class": _ctx.tableCellFirstHoveredClass,
      "table-cell-within-hovered-class": _ctx.tableCellWithinHoveredClass,
      "table-cell-last-hovered-class": _ctx.tableCellLastHoveredClass,
      "table-cell-today-class": _ctx.tableCellTodayClass,
      "table-cell-selectable-class": _ctx.tableCellSelectableClass,
      "table-cell-unselectable-class": _ctx.tableCellUnselectableClass,
      "table-cell-nearby-class": _ctx.tableCellNearbyClass,
      "table-cell-events-class": _ctx.tableCellEventsClass,
      "table-events-class": _ctx.tableEventsClass,
      "table-event-variant-class": _ctx.tableEventVariantClass,
      "table-event-class": _ctx.tableEventClass,
      "table-event-indicators-class": _ctx.tableEventIndicatorsClass,
      onSelect: _ctx.updateSelectedDate,
      onRangeHoverEndDate: _ctx.setRangeHoverEndDate,
      "onChange-focus": _ctx.changeFocus
    }, null, 8
    /* PROPS */
    , ["selected-date", "day", "week", "month", "min-date", "max-date", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "nearby-month-days", "nearby-selectable-month-days", "show-week-number", "week-number-clickable", "first-day-of-week", "rules-for-first-week", "range", "hovered-date-range", "multiple", "table-row-class", "table-cell-class", "table-cell-selected-class", "table-cell-first-selected-class", "table-cell-invisible-class", "table-cell-within-selected-class", "table-cell-last-selected-class", "table-cell-first-hovered-class", "table-cell-within-hovered-class", "table-cell-last-hovered-class", "table-cell-today-class", "table-cell-selectable-class", "table-cell-unselectable-class", "table-cell-nearby-class", "table-cell-events-class", "table-events-class", "table-event-variant-class", "table-event-class", "table-event-indicators-class", "onSelect", "onRangeHoverEndDate", "onChange-focus"]);
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

script$1.render = render$1;
script$1.__file = "src/components/datepicker/DatepickerTable.vue";

var DatepickerMixin = {
    methods: {
        manageKeydown(event, weekDay) {
            // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
            const { key } = event;
            let preventDefault = true;
            switch (key) {
                case 'Tab': {
                    preventDefault = false;
                    break;
                }
                case ' ':
                case 'Space':
                case 'Spacebar':
                case 'Enter': {
                    this.emitChosenDate(weekDay);
                    break;
                }
                case 'ArrowLeft':
                case 'Left': {
                    this.changeFocus(weekDay, -1);
                    break;
                }
                case 'ArrowRight':
                case 'Right': {
                    this.changeFocus(weekDay, 1);
                    break;
                }
                case 'ArrowUp':
                case 'Up': {
                    this.changeFocus(weekDay, -7);
                    break;
                }
                case 'ArrowDown':
                case 'Down': {
                    this.changeFocus(weekDay, 7);
                    break;
                }
            }
            if (preventDefault) {
                event.preventDefault();
            }
        }
    }
};

var script$2 = {
    name: 'ODatepickerMonth',
    mixins: [plugins$1.BaseComponentMixin, DatepickerMixin],
    configField: 'datepicker',
    emits: ['update:modelValue', 'range-start', 'range-end', 'updated:focused'],
    props: {
        modelValue: {
            type: [Date, Array]
        },
        monthNames: Array,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        range: Boolean,
        multiple: Boolean,
        monthClass: [String, Function, Array],
        monthBodyClass: [String, Function, Array],
        monthTableClass: [String, Function, Array],
        monthCellClass: [String, Function, Array],
        monthCellSelectedClass: [String, Function, Array],
        monthCellFirstSelectedClass: [String, Function, Array],
        monthCellWithinSelectedClass: [String, Function, Array],
        monthCellLastSelectedClass: [String, Function, Array],
        monthCellWithinHoveredRangeClass: [String, Function, Array],
        monthCellFirstHoveredClass: [String, Function, Array],
        monthCellWithinHoveredClass: [String, Function, Array],
        monthCellLastHoveredClass: [String, Function, Array],
        monthCellTodayClass: [String, Function, Array],
        monthCellSelectableClass: [String, Function, Array],
        monthCellUnselectableClass: [String, Function, Array],
        monthCellEventsClass: [String, Function, Array]
    },
    data() {
        return {
            selectedBeginDate: undefined,
            selectedEndDate: undefined,
            hoveredEndDate: undefined,
            multipleSelectedDates: this.multiple && this.modelValue ? this.modelValue : []
        };
    },
    computed: {
        monthClasses() {
            return [
                this.computedClass('monthClass', 'o-dpck__month')
            ];
        },
        monthBodyClasses() {
            return [
                this.computedClass('monthBodyClass', 'o-dpck__month__body')
            ];
        },
        monthTableClasses() {
            return [
                this.computedClass('monthTableClass', 'o-dpck__month__table')
            ];
        },
        monthCellClasses() {
            return [
                this.computedClass('monthCellClass', 'o-dpck__month__cell')
            ];
        },
        hasEvents() {
            return this.events && this.events.length;
        },
        /*
        * Return array of all events in the specified month
        */
        eventsInThisYear() {
            if (!this.events)
                return [];
            const yearEvents = [];
            for (let i = 0; i < this.events.length; i++) {
                let event = this.events[i];
                if (!Object.prototype.hasOwnProperty.call(event, 'date')) {
                    event = { date: event };
                }
                if (!Object.prototype.hasOwnProperty.call(event, 'type')) {
                    event.type = 'is-primary';
                }
                if (event.date.getFullYear() === this.focused.year) {
                    yearEvents.push(event);
                }
            }
            return yearEvents;
        },
        monthDates() {
            const year = this.focused.year;
            const months = [];
            for (let i = 0; i < 12; i++) {
                const d = new Date(year, i, 1);
                d.setHours(0, 0, 0, 0);
                months.push(d);
            }
            return months;
        },
        focusedMonth() {
            return this.focused.month;
        },
        hoveredDateRange() {
            if (!this.range) {
                return [];
            }
            if (!isNaN(this.selectedEndDate)) {
                return [];
            }
            if (this.hoveredEndDate < this.selectedBeginDate) {
                return [this.hoveredEndDate, this.selectedBeginDate].filter(helpers.isDefined);
            }
            return [this.selectedBeginDate, this.hoveredEndDate].filter(helpers.isDefined);
        }
    },
    watch: {
        focusedMonth(month) {
            const refName = `month-${month}`;
            if (this.$refs[refName] && this.$refs[refName].length > 0) {
                this.$nextTick(() => {
                    if (this.$refs[refName][0]) {
                        this.$refs[refName][0].focus();
                    }
                }); // $nextTick needed when year is changed
            }
        }
    },
    methods: {
        selectMultipleDates(date) {
            const multipleSelect = this.multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() === date.getDate() &&
                selectedDate.getFullYear() === date.getFullYear() &&
                selectedDate.getMonth() === date.getMonth());
            if (multipleSelect.length) {
                this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() !== date.getDate() ||
                    selectedDate.getFullYear() !== date.getFullYear() ||
                    selectedDate.getMonth() !== date.getMonth());
            }
            else {
                this.multipleSelectedDates.push(date);
            }
            this.$emit('update:modelValue', this.multipleSelectedDates);
        },
        selectableDate(day) {
            const validity = [];
            if (this.minDate) {
                validity.push(day >= this.minDate);
            }
            if (this.maxDate) {
                validity.push(day <= this.maxDate);
            }
            validity.push(day.getFullYear() === this.focused.year);
            if (this.selectableDates) {
                if (typeof this.selectableDates === 'function') {
                    if (this.selectableDates(day)) {
                        return true;
                    }
                    else {
                        validity.push(false);
                    }
                }
                else {
                    for (let i = 0; i < this.selectableDates.length; i++) {
                        const enabledDate = this.selectableDates[i];
                        if (day.getFullYear() === enabledDate.getFullYear() &&
                            day.getMonth() === enabledDate.getMonth()) {
                            return true;
                        }
                        else {
                            validity.push(false);
                        }
                    }
                }
            }
            if (this.unselectableDates) {
                if (typeof this.unselectableDates === 'function') {
                    validity.push(!this.unselectableDates(day));
                }
                else {
                    for (let i = 0; i < this.unselectableDates.length; i++) {
                        const disabledDate = this.unselectableDates[i];
                        validity.push(day.getFullYear() !== disabledDate.getFullYear() ||
                            day.getMonth() !== disabledDate.getMonth());
                    }
                }
            }
            if (this.unselectableDaysOfWeek) {
                for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
                    const dayOfWeek = this.unselectableDaysOfWeek[i];
                    validity.push(day.getDay() !== dayOfWeek);
                }
            }
            return validity.indexOf(false) < 0;
        },
        eventsDateMatch(day) {
            if (!this.eventsInThisYear.length)
                return false;
            const monthEvents = [];
            for (let i = 0; i < this.eventsInThisYear.length; i++) {
                if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {
                    monthEvents.push(this.events[i]);
                }
            }
            if (!monthEvents.length) {
                return false;
            }
            return monthEvents;
        },
        /*
        * Build cellClasses for cell using validations
        */
        cellClasses(day) {
            function dateMatch(dateOne, dateTwo, multiple = false) {
                // if either date is null or undefined, return false
                if (!dateOne || !dateTwo || multiple) {
                    return false;
                }
                if (Array.isArray(dateTwo)) {
                    return dateTwo.some((date) => (dateOne.getFullYear() === date.getFullYear() &&
                        dateOne.getMonth() === date.getMonth()));
                }
                return (dateOne.getFullYear() === dateTwo.getFullYear() &&
                    dateOne.getMonth() === dateTwo.getMonth());
            }
            function dateWithin(dateOne, dates, multiple = false) {
                if (!Array.isArray(dates) || multiple) {
                    return false;
                }
                return dateOne > dates[0] && dateOne < dates[1];
            }
            function dateMultipleSelected(dateOne, dates, multiple = false) {
                if (!Array.isArray(dates) || !multiple) {
                    return false;
                }
                return dates.some((date) => (dateOne.getDate() === date.getDate() &&
                    dateOne.getFullYear() === date.getFullYear() &&
                    dateOne.getMonth() === date.getMonth()));
            }
            return [
                ...this.monthCellClasses,
                {
                    [this.computedClass('monthCellSelectedClass', 'o-dpck__month__cell--selected')]: dateMatch(day, this.modelValue, this.multiple) ||
                        dateWithin(day, this.modelValue, this.multiple) ||
                        dateMultipleSelected(day, this.multipleSelectedDates, this.multiple)
                },
                {
                    [this.computedClass('monthCellFirstSelectedClass', 'o-dpck__month__cell--first-selected')]: dateMatch(day, Array.isArray(this.modelValue) && this.modelValue[0], this.multiple)
                },
                {
                    [this.computedClass('monthCellWithinSelectedClass', 'o-dpck__month__cell--within-selected')]: dateWithin(day, this.modelValue, this.multiple)
                },
                {
                    [this.computedClass('monthCellLastSelectedClass', 'o-dpck__month__cell--last-selected')]: dateMatch(day, Array.isArray(this.modelValue) && this.modelValue[1], this.multiple)
                },
                {
                    [this.computedClass('monthCellWithinHoveredRangeClass', 'o-dpck__month__cell--within-hovered-range')]: this.hoveredDateRange && this.hoveredDateRange.length === 2 &&
                        (dateMatch(day, this.hoveredDateRange) ||
                            dateWithin(day, this.hoveredDateRange))
                },
                {
                    [this.computedClass('monthCellFirstHoveredClass', 'o-dpck__month__cell--first-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0])
                },
                {
                    [this.computedClass('monthCellWithinHoveredClass', 'o-dpck__month__cell--within-hovered')]: dateWithin(day, this.hoveredDateRange)
                },
                {
                    [this.computedClass('monthCellLastHoveredClass', 'o-dpck__month__cell--last-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1])
                },
                {
                    [this.computedClass('monthCellTodayClass', 'o-dpck__month__cell--today')]: dateMatch(day, this.dateCreator())
                },
                {
                    [this.computedClass('monthCellSelectableclass', 'o-dpck__month__cell--selectable')]: this.selectableDate(day) && !this.disabled
                },
                {
                    [this.computedClass('monthCellUnselectableClass', 'o-dpck__month__cell--unselectable')]: !this.selectableDate(day) || this.disabled
                },
                {
                    [this.computedClass('monthCellEventsClass', 'o-dpck__month__cell--events')]: this.hasEvents
                },
            ];
        },
        /*
         * Emit update:modelValue event with selected date as payload for v-model in parent
         */
        updateSelectedDate(date) {
            if (!this.range && !this.multiple) {
                this.emitChosenDate(date);
            }
            else if (this.range) {
                this.handleSelectRangeDate(date);
            }
            else if (this.multiple) {
                this.selectMultipleDates(date);
            }
        },
        /*
         * Emit select event with chosen date as payload
         */
        emitChosenDate(day) {
            if (this.disabled)
                return;
            if (!this.multiple) {
                if (this.selectableDate(day)) {
                    this.$emit('update:modelValue', day);
                }
            }
            else {
                this.selectMultipleDates(day);
            }
        },
        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate(date) {
            if (this.disabled)
                return;
            if (this.selectedBeginDate && this.selectedEndDate) {
                this.selectedBeginDate = date;
                this.selectedEndDate = undefined;
                this.$emit('range-start', date);
            }
            else if (this.selectedBeginDate && !this.selectedEndDate) {
                if (this.selectedBeginDate > date) {
                    this.selectedEndDate = this.selectedBeginDate;
                    this.selectedBeginDate = date;
                }
                else {
                    this.selectedEndDate = date;
                }
                this.$emit('range-end', date);
                this.$emit('update:modelValue', [this.selectedBeginDate, this.selectedEndDate]);
            }
            else {
                this.selectedBeginDate = date;
                this.$emit('range-start', date);
            }
        },
        setRangeHoverEndDate(day) {
            if (this.range) {
                this.hoveredEndDate = day;
            }
        },
        changeFocus(month, inc) {
            const nextMonth = month;
            nextMonth.setMonth(month.getMonth() + inc);
            this.$emit('update:focused', nextMonth);
        }
    }
};

const _hoisted_1 = {
  key: 0,
  class: "events"
};
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createBlock("section", {
    class: $options.monthClasses
  }, [vue.createVNode("div", {
    class: $options.monthBodyClasses
  }, [vue.createVNode("div", {
    class: $options.monthTableClasses
  }, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($options.monthDates, (date, index) => {
    return vue.openBlock(), vue.createBlock(vue.Fragment, {
      key: index
    }, [$options.selectableDate(date) && !$props.disabled ? (vue.openBlock(), vue.createBlock("a", {
      key: 0,
      ref: `month-${date.getMonth()}`,
      class: $options.cellClasses(date),
      role: "button",
      href: "#",
      disabled: $props.disabled,
      onClick: vue.withModifiers($event => $options.updateSelectedDate(date), ["prevent"]),
      onMouseenter: $event => $options.setRangeHoverEndDate(date),
      onKeydown: vue.withModifiers($event => _ctx.manageKeydown($event, date), ["prevent"]),
      tabindex: $props.focused.month === date.getMonth() ? null : -1
    }, [vue.createTextVNode(vue.toDisplayString($props.monthNames[date.getMonth()]) + " ", 1
    /* TEXT */
    ), $options.eventsDateMatch(date) ? (vue.openBlock(), vue.createBlock("div", _hoisted_1, [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList($options.eventsDateMatch(date), (event, index) => {
      return vue.openBlock(), vue.createBlock("div", {
        class: ["event", event.type],
        key: index
      }, null, 2
      /* CLASS */
      );
    }), 128
    /* KEYED_FRAGMENT */
    ))])) : vue.createCommentVNode("v-if", true)], 42
    /* CLASS, PROPS, HYDRATE_EVENTS */
    , ["disabled", "onClick", "onMouseenter", "onKeydown", "tabindex"])) : (vue.openBlock(), vue.createBlock("div", {
      key: 1,
      class: $options.cellClasses(date)
    }, vue.toDisplayString($props.monthNames[date.getMonth()]), 3
    /* TEXT, CLASS */
    ))], 64
    /* STABLE_FRAGMENT */
    );
  }), 128
  /* KEYED_FRAGMENT */
  ))], 2
  /* CLASS */
  )], 2
  /* CLASS */
  )], 2
  /* CLASS */
  );
}

script$2.render = render$2;
script$2.__file = "src/components/datepicker/DatepickerMonth.vue";

const defaultDateFormatter = (date, vm) => {
    const targetDates = Array.isArray(date) ? date : [date];
    const dates = targetDates.map((date) => {
        const d = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12);
        return !vm.isTypeMonth ? vm.dtf.format(d) : vm.dtfMonth.format(d);
    });
    return !vm.multiple ? dates.join(' - ') : dates.join(', ');
};
const defaultDateParser = (date, vm) => {
    if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
        const formatRegex = (vm.isTypeMonth ? vm.dtfMonth : vm.dtf)
            .formatToParts(new Date(2000, 11, 25)).map((part) => {
            if (part.type === 'literal') {
                return part.value;
            }
            return `((?!=<${part.type}>)\\d+)`;
        }).join('');
        const dateGroups = helpers.matchWithGroups(formatRegex, date);
        // We do a simple validation for the group.
        // If it is not valid, it will fallback to Date.parse below
        if (dateGroups.year &&
            dateGroups.year.length === 4 &&
            dateGroups.month &&
            dateGroups.month <= 12) {
            if (vm.isTypeMonth)
                return new Date(dateGroups.year, dateGroups.month - 1);
            else if (dateGroups.day && dateGroups.day <= 31) {
                return new Date(dateGroups.year, dateGroups.month - 1, dateGroups.day, 12);
            }
        }
    }
    // Fallback if formatToParts is not supported or if we were not able to parse a valid date
    if (!vm.isTypeMonth)
        return new Date(Date.parse(date));
    if (date) {
        const s = date.split('/');
        const year = s[0].length === 4 ? s[0] : s[1];
        const month = s[0].length === 2 ? s[0] : s[1];
        if (year && month) {
            return new Date(parseInt(year, 10), parseInt(month, 10) - 1, 1, 0, 0, 0, 0);
        }
    }
    return null;
};
/**
 * An input with a simple dropdown/modal for selecting a date, uses native datepicker for mobile
 * @displayName Datepicker
 * @style _datepicker.scss
 */
var script$3 = vue.defineComponent({
    name: 'ODatepicker',
    components: {
        [script$1.name]: script$1,
        [script$2.name]: script$2,
        [Field.script.name]: Field.script,
        [Input.script.name]: Input.script,
        [Select.script.name]: Select.script,
        [Icon.script.name]: Icon.script,
        [DropdownItem.script.name]: DropdownItem.script,
        [DropdownItem.script$1.name]: DropdownItem.script$1
    },
    configField: 'datepicker',
    mixins: [plugins$1.BaseComponentMixin, FormElementMixin.FormElementMixin, MatchMediaMixin.MatchMediaMixin],
    inheritAttrs: false,
    provide() {
        return {
            $datepicker: this
        };
    },
    emits: ['update:modelValue', 'focus', 'blur', 'change-month', 'change-year', 'range-start', 'range-end', 'active-change', 'icon-right-click'],
    props: {
        modelValue: {
            type: [Date, Array]
        },
        dayNames: {
            type: Array,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.dayNames', undefined);
            }
        },
        monthNames: {
            type: Array,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.monthNames', undefined);
            }
        },
        firstDayOfWeek: {
            type: Number,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.firstDayOfWeek', 0);
            }
        },
        /**
         * Size of button, optional
         * @values small, medium, large
         */
        size: String,
        inline: Boolean,
        minDate: Date,
        maxDate: Date,
        focusedDate: Date,
        placeholder: String,
        editable: Boolean,
        disabled: Boolean,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: {
            type: Array,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.unselectableDaysOfWeek', undefined);
            }
        },
        selectableDates: [Array, Function],
        dateFormatter: {
            type: Function,
            default: (date, vm) => {
                const dateFormatter = helpers.getValueByPath(config.getOptions(), 'datepicker.dateFormatter', undefined);
                if (typeof dateFormatter === 'function') {
                    return dateFormatter(date);
                }
                else {
                    return defaultDateFormatter(date, vm);
                }
            }
        },
        dateParser: {
            type: Function,
            default: (date, vm) => {
                const dateParser = helpers.getValueByPath(config.getOptions(), 'datepicker.dateParser', undefined);
                if (typeof dateParser === 'function') {
                    return dateParser(date);
                }
                else {
                    return defaultDateParser(date, vm);
                }
            }
        },
        dateCreator: {
            type: Function,
            default: () => {
                const dateCreator = helpers.getValueByPath(config.getOptions(), 'datepicker.dateCreator', undefined);
                if (typeof dateCreator === 'function') {
                    return dateCreator();
                }
                else {
                    return new Date();
                }
            }
        },
        mobileNative: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.mobileNative', true);
            }
        },
        position: String,
        iconRight: String,
        iconRightClickable: Boolean,
        events: Array,
        indicators: {
            type: String,
            default: 'dots'
        },
        openOnFocus: Boolean,
        iconPrev: {
            type: String,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.iconPrev', 'chevron-left');
            }
        },
        iconNext: {
            type: String,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.iconNext', 'chevron-right');
            }
        },
        yearsRange: {
            type: Array,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.yearsRange', [-100, 10]);
            }
        },
        type: {
            type: String,
            validator: (value) => {
                return [
                    'month'
                ].indexOf(value) >= 0;
            }
        },
        nearbyMonthDays: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.nearbyMonthDays', true);
            }
        },
        nearbySelectableMonthDays: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.nearbySelectableMonthDays', false);
            }
        },
        showWeekNumber: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.showWeekNumber', false);
            }
        },
        weekNumberClickable: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.weekNumberClickable', false);
            }
        },
        rulesForFirstWeek: {
            type: Number,
            default: () => 4
        },
        range: {
            type: Boolean,
            default: false
        },
        closeOnClick: {
            type: Boolean,
            default: true
        },
        multiple: {
            type: Boolean,
            default: false
        },
        mobileModal: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.mobileModal', true);
            }
        },
        trapFocus: {
            type: Boolean,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.trapFocus', true);
            }
        },
        locale: {
            type: [String, Array],
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'locale');
            }
        },
        appendToBody: Boolean,
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        rootClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        boxClass: [String, Function, Array],
        headerClass: [String, Function, Array],
        headerButtonsClass: [String, Function, Array],
        headerButtonsSizeClass: [String, Function, Array],
        prevBtnClass: [String, Function, Array],
        nextBtnClass: [String, Function, Array],
        listsClass: [String, Function, Array],
        footerClass: [String, Function, Array],
        tableClass: [String, Function, Array],
        tableHeadClass: [String, Function, Array],
        tableHeadCellClass: [String, Function, Array],
        tableBodyClass: [String, Function, Array],
        tableRowClass: [String, Function, Array],
        tableCellClass: [String, Function, Array],
        tableCellSelectedClass: [String, Function, Array],
        tableCellFirstSelectedClass: [String, Function, Array],
        tableCellInvisibleClass: [String, Function, Array],
        tableCellWithinSelectedClass: [String, Function, Array],
        tableCellLastSelectedClass: [String, Function, Array],
        tableCellFirstHoveredClass: [String, Function, Array],
        tableCellWithinHoveredClass: [String, Function, Array],
        tableCellLastHoveredClass: [String, Function, Array],
        tableCellTodayClass: [String, Function, Array],
        tableCellSelectableClass: [String, Function, Array],
        tableCellUnselectableClass: [String, Function, Array],
        tableCellNearbyClass: [String, Function, Array],
        tableCellEventsClass: [String, Function, Array],
        tableEventsClass: [String, Function, Array],
        tableEventVariantClass: [String, Function, Array],
        tableEventClass: [String, Function, Array],
        tableEventIndicatorsClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        /* datapickermonth classes */
        monthClass: [String, Function, Array],
        monthBodyClass: [String, Function, Array],
        monthTableClass: [String, Function, Array],
        monthCellClass: [String, Function, Array],
        monthCellSelectedClass: [String, Function, Array],
        monthCellFirstSelectedClass: [String, Function, Array],
        monthCellWithinSelectedClass: [String, Function, Array],
        monthCellLastSelectedClass: [String, Function, Array],
        monthCellWithinHoveredRangeClass: [String, Function, Array],
        monthCellFirstHoveredClass: [String, Function, Array],
        monthCellWithinHoveredClass: [String, Function, Array],
        monthCellLastHoveredClass: [String, Function, Array],
        monthCellTodayClass: [String, Function, Array],
        monthCellSelectableClass: [String, Function, Array],
        monthCellUnselectableClass: [String, Function, Array],
        monthCellEventsClass: [String, Function, Array],
        inputClasses: {
            type: Object,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.inputClasses', {});
            }
        },
        dropdownClasses: {
            type: Object,
            default: () => {
                return helpers.getValueByPath(config.getOptions(), 'datepicker.dropdownClasses', {});
            }
        },
        selectListClasses: Object
    },
    data() {
        const focusedDate = (Array.isArray(this.modelValue) ? this.modelValue[0] : (this.modelValue)) ||
            this.focusedDate || this.dateCreator();
        if (!this.modelValue && this.maxDate && this.maxDate.getFullYear() < focusedDate.getFullYear()) {
            focusedDate.setFullYear(this.maxDate.getFullYear());
        }
        return {
            dateSelected: this.modelValue,
            focusedDateData: {
                day: focusedDate.getDate(),
                month: focusedDate.getMonth(),
                year: focusedDate.getFullYear()
            }
        };
    },
    computed: {
        inputBind() {
            return {
                ...this.$attrs,
                ...this.inputClasses
            };
        },
        dropdownBind() {
            return {
                'root-class': this.computedClass('dropdownClasses.rootClass', 'o-dpck__dropdown'),
                ...this.dropdownClasses
            };
        },
        selectListBind() {
            return {
                ...this.selectListClasses
            };
        },
        rootClasses() {
            return [
                this.computedClass('rootClass', 'o-dpck'),
                { [this.computedClass('sizeClass', 'o-dpck--', this.size)]: this.size },
                { [this.computedClass('mobileClass', 'o-dpck--mobile')]: this.isMatchMedia },
            ];
        },
        boxClasses() {
            return [
                this.computedClass('boxClass', 'o-dpck__box')
            ];
        },
        headerClasses() {
            return [
                this.computedClass('headerClass', 'o-dpck__header')
            ];
        },
        headerButtonsClasses() {
            return [
                this.computedClass('headerButtonsClass', 'o-dpck__header__buttons'),
                { [this.computedClass('headerButtonsSizeClass', 'o-dpck__header__buttons--', this.size)]: this.size },
            ];
        },
        prevBtnClasses() {
            return [
                this.computedClass('prevBtnClass', 'o-dpck__header__previous')
            ];
        },
        nextBtnClasses() {
            return [
                this.computedClass('nextBtnClass', 'o-dpck__header__next')
            ];
        },
        listsClasses() {
            return [
                this.computedClass('listsClass', 'o-dpck__header__list')
            ];
        },
        footerClasses() {
            return [
                this.computedClass('footerClass', 'o-dpck__footer')
            ];
        },
        computedValue: {
            get() {
                return this.dateSelected;
            },
            set(value) {
                this.updateInternalState(value);
                if (!this.multiple)
                    this.togglePicker(false);
                this.$emit('update:modelValue', value);
                if (this.useHtml5Validation) {
                    this.$nextTick(() => {
                        this.checkHtml5Validity();
                    });
                }
            }
        },
        formattedValue() {
            return this.formatValue(this.computedValue);
        },
        localeOptions() {
            return new Intl.DateTimeFormat(this.locale, {
                year: 'numeric',
                month: 'numeric'
            }).resolvedOptions();
        },
        dtf() {
            return new Intl.DateTimeFormat(this.locale /*, { timeZone: 'UTC' }*/);
        },
        dtfMonth() {
            return new Intl.DateTimeFormat(this.locale, {
                year: this.localeOptions.year || 'numeric',
                month: this.localeOptions.month || '2-digit',
            });
        },
        newMonthNames() {
            if (Array.isArray(this.monthNames)) {
                return this.monthNames;
            }
            return helpers.getMonthNames(this.locale);
        },
        newDayNames() {
            if (Array.isArray(this.dayNames)) {
                return this.dayNames;
            }
            return helpers.getWeekdayNames(this.locale);
        },
        listOfMonths() {
            let minMonth = 0;
            let maxMonth = 12;
            if (this.minDate && this.focusedDateData.year === this.minDate.getFullYear()) {
                minMonth = this.minDate.getMonth();
            }
            if (this.maxDate && this.focusedDateData.year === this.maxDate.getFullYear()) {
                maxMonth = this.maxDate.getMonth();
            }
            return this.newMonthNames.map((name, index) => {
                return {
                    name: name,
                    index: index,
                    disabled: index < minMonth || index > maxMonth
                };
            });
        },
        /*
         * Returns an array of years for the year dropdown. If earliest/latest
         * dates are set by props, range of years will fall within those dates.
         */
        listOfYears() {
            let latestYear = this.focusedDateData.year + this.yearsRange[1];
            if (this.maxDate && this.maxDate.getFullYear() < latestYear) {
                latestYear = Math.max(this.maxDate.getFullYear(), this.focusedDateData.year);
            }
            let earliestYear = this.focusedDateData.year + this.yearsRange[0];
            if (this.minDate && this.minDate.getFullYear() > earliestYear) {
                earliestYear = Math.min(this.minDate.getFullYear(), this.focusedDateData.year);
            }
            const arrayOfYears = [];
            for (let i = earliestYear; i <= latestYear; i++) {
                arrayOfYears.push(i);
            }
            return arrayOfYears.reverse();
        },
        showPrev() {
            if (!this.minDate)
                return false;
            if (this.isTypeMonth) {
                return this.focusedDateData.year <= this.minDate.getFullYear();
            }
            const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
            const date = new Date(this.minDate.getFullYear(), this.minDate.getMonth());
            return (dateToCheck <= date);
        },
        showNext() {
            if (!this.maxDate)
                return false;
            if (this.isTypeMonth) {
                return this.focusedDateData.year >= this.maxDate.getFullYear();
            }
            const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
            const date = new Date(this.maxDate.getFullYear(), this.maxDate.getMonth());
            return (dateToCheck >= date);
        },
        isMobile() {
            return this.mobileNative && helpers.isMobile.any();
        },
        isTypeMonth() {
            return this.type === 'month';
        },
        ariaRole() {
            return !this.inline ? 'dialog' : undefined;
        },
        $elementRef() {
            return 'input';
        }
    },
    watch: {
        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        modelValue(value) {
            this.updateInternalState(value);
            if (!this.multiple)
                this.togglePicker(false);
        },
        focusedDate(value) {
            if (value) {
                this.focusedDateData = {
                    day: value.getDate(),
                    month: value.getMonth(),
                    year: value.getFullYear()
                };
            }
        },
        /*
         * Emit input event on month and/or year change
         */
        'focusedDateData.month'(value) {
            this.$emit('change-month', value);
        },
        'focusedDateData.year'(value) {
            this.$emit('change-year', value);
        }
    },
    methods: {
        /*
         * Parse string into date
         */
        onChange(value) {
            const date = this.dateParser(value, this);
            if (date && (!isNaN(date) ||
                (Array.isArray(date) && date.length === 2 && !isNaN(date[0]) && !isNaN(date[1])))) {
                this.computedValue = date;
            }
            else {
                // Force refresh input value when not valid date
                this.computedValue = null;
                if (this.$refs.input) {
                    this.$refs.input.newValue = this.computedValue;
                }
            }
        },
        /*
         * Format date into string
         */
        formatValue(value) {
            if (Array.isArray(value)) {
                const isArrayWithValidDates = Array.isArray(value) && value.every((v) => !isNaN(v));
                return isArrayWithValidDates ? this.dateFormatter([...value], this) : null;
            }
            return (value && !isNaN(value)) ? this.dateFormatter(value, this) : null;
        },
        /*
         * Either decrement month by 1 if not January or decrement year by 1
         * and set month to 11 (December) or decrement year when 'month'
         */
        prev() {
            if (this.disabled)
                return;
            if (this.isTypeMonth) {
                this.focusedDateData.year -= 1;
            }
            else {
                if (this.focusedDateData.month > 0) {
                    this.focusedDateData.month -= 1;
                }
                else {
                    this.focusedDateData.month = 11;
                    this.focusedDateData.year -= 1;
                }
            }
        },
        /*
         * Either increment month by 1 if not December or increment year by 1
         * and set month to 0 (January) or increment year when 'month'
         */
        next() {
            if (this.disabled)
                return;
            if (this.isTypeMonth) {
                this.focusedDateData.year += 1;
            }
            else {
                if (this.focusedDateData.month < 11) {
                    this.focusedDateData.month += 1;
                }
                else {
                    this.focusedDateData.month = 0;
                    this.focusedDateData.year += 1;
                }
            }
        },
        formatNative(value) {
            return this.isTypeMonth
                ? this.formatYYYYMM(value) : this.formatYYYYMMDD(value);
        },
        /*
         * Format date into string 'YYYY-MM-DD'
         */
        formatYYYYMMDD(value) {
            const date = new Date(value);
            if (value && !isNaN(date.getTime())) {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                const day = date.getDate();
                return year + '-' +
                    ((month < 10 ? '0' : '') + month) + '-' +
                    ((day < 10 ? '0' : '') + day);
            }
            return '';
        },
        /*
         * Format date into string 'YYYY-MM'
         */
        formatYYYYMM(value) {
            const date = new Date(value);
            if (value && !isNaN(date.getTime())) {
                const year = date.getFullYear();
                const month = date.getMonth() + 1;
                return year + '-' +
                    ((month < 10 ? '0' : '') + month);
            }
            return '';
        },
        /*
         * Parse date from string
         */
        onChangeNativePicker(event) {
            const date = event.target.value;
            const s = date ? date.split('-') : [];
            if (s.length === 3) {
                const year = parseInt(s[0], 10);
                const month = parseInt(s[1]) - 1;
                const day = parseInt(s[2]);
                this.computedValue = new Date(year, month, day);
            }
            else {
                this.computedValue = null;
            }
        },
        updateInternalState(value) {
            if (this.dateSelected === value)
                return;
            const isArray = Array.isArray(value);
            const currentDate = isArray
                ? (!value.length ? this.dateCreator() : value[value.length - 1])
                : (!value ? this.dateCreator() : value);
            if (!isArray || (isArray && this.dateSelected && value.length > this.dateSelected.length)) {
                this.focusedDateData = {
                    day: currentDate.getDate(),
                    month: currentDate.getMonth(),
                    year: currentDate.getFullYear()
                };
            }
            this.dateSelected = value;
        },
        /*
         * Toggle datepicker
         */
        togglePicker(active) {
            if (this.$refs.dropdown) {
                const isActive = typeof active === 'boolean'
                    ? active
                    : !this.$refs.dropdown.isActive;
                if (isActive) {
                    this.$refs.dropdown.isActive = isActive;
                }
                else if (this.closeOnClick) {
                    this.$refs.dropdown.isActive = isActive;
                }
            }
        },
        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus(event) {
            this.onFocus(event);
            if (this.openOnFocus) {
                this.togglePicker(true);
            }
        },
        /*
         * Toggle dropdown
         */
        toggle() {
            if (this.mobileNative && this.isMobile) {
                const input = this.$refs.input.$refs.input;
                input.focus();
                input.click();
                return;
            }
            this.$refs.dropdown.toggle();
        },
        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick(event) {
            if (this.$refs.dropdown.isActive) {
                event.stopPropagation();
            }
        },
        /**
         * Keypress event that is bound to the document.
         */
        keyPress({ key }) {
            if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
                this.togglePicker(false);
            }
        },
        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange(value) {
            if (!value) {
                this.onBlur();
            }
            this.$emit('active-change', value);
        },
        changeFocus(day) {
            this.focusedDateData = {
                day: day.getDate(),
                month: day.getMonth(),
                year: day.getFullYear()
            };
        }
    },
    created() {
        if (typeof window !== 'undefined') {
            document.addEventListener('keyup', this.keyPress);
        }
    },
    beforeUnmount() {
        if (typeof window !== 'undefined') {
            document.removeEventListener('keyup', this.keyPress);
        }
    }
});

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_input = vue.resolveComponent("o-input");

  const _component_o_icon = vue.resolveComponent("o-icon");

  const _component_o_select = vue.resolveComponent("o-select");

  const _component_o_datepicker_table = vue.resolveComponent("o-datepicker-table");

  const _component_o_datepicker_month = vue.resolveComponent("o-datepicker-month");

  const _component_o_dropdown_item = vue.resolveComponent("o-dropdown-item");

  const _component_o_dropdown = vue.resolveComponent("o-dropdown");

  return vue.openBlock(), vue.createBlock("div", {
    class: _ctx.rootClasses
  }, [!_ctx.isMobile || _ctx.inline ? vue.createVNode(_component_o_dropdown, vue.mergeProps({
    key: 0,
    ref: "dropdown"
  }, _ctx.dropdownBind, {
    position: _ctx.position,
    disabled: _ctx.disabled,
    inline: _ctx.inline,
    "mobile-modal": _ctx.mobileModal,
    "trap-focus": _ctx.trapFocus,
    "aria-role": _ctx.ariaRole,
    "aria-modal": !_ctx.inline,
    "trigger-tabindex": -1,
    "append-to-body": _ctx.appendToBody,
    "append-to-body-copy-parent": "",
    "onActive-change": _ctx.onActiveChange
  }), vue.createSlots({
    default: vue.withCtx(() => [vue.createVNode(_component_o_dropdown_item, {
      override: "",
      tag: "div",
      "item-class": _ctx.boxClasses,
      disabled: _ctx.disabled,
      clickable: false
    }, {
      default: vue.withCtx(() => [vue.createVNode("header", {
        class: _ctx.headerClasses
      }, [vue.renderSlot(_ctx.$slots, "header", {}, () => [vue.createVNode("div", {
        class: _ctx.headerButtonsClasses
      }, [vue.withDirectives(vue.createVNode("a", {
        class: _ctx.prevBtnClasses,
        role: "button",
        href: "#",
        "aria-label": _ctx.ariaPreviousLabel,
        onClick: _cache[4] || (_cache[4] = vue.withModifiers((...args) => _ctx.prev(...args), ["prevent"])),
        onKeydown: [_cache[5] || (_cache[5] = vue.withKeys(vue.withModifiers((...args) => _ctx.prev(...args), ["prevent"]), ["enter"])), _cache[6] || (_cache[6] = vue.withKeys(vue.withModifiers((...args) => _ctx.prev(...args), ["prevent"]), ["space"]))]
      }, [vue.createVNode(_component_o_icon, {
        icon: _ctx.iconPrev,
        pack: _ctx.iconPack,
        both: "",
        clickable: ""
      }, null, 8
      /* PROPS */
      , ["icon", "pack"])], 42
      /* CLASS, PROPS, HYDRATE_EVENTS */
      , ["aria-label"]), [[vue.vShow, !_ctx.showPrev && !_ctx.disabled]]), vue.withDirectives(vue.createVNode("a", {
        class: _ctx.nextBtnClasses,
        role: "button",
        href: "#",
        "aria-label": _ctx.ariaNextLabel,
        onClick: _cache[7] || (_cache[7] = vue.withModifiers((...args) => _ctx.next(...args), ["prevent"])),
        onKeydown: [_cache[8] || (_cache[8] = vue.withKeys(vue.withModifiers((...args) => _ctx.next(...args), ["prevent"]), ["enter"])), _cache[9] || (_cache[9] = vue.withKeys(vue.withModifiers((...args) => _ctx.next(...args), ["prevent"]), ["space"]))]
      }, [vue.createVNode(_component_o_icon, {
        icon: _ctx.iconNext,
        pack: _ctx.iconPack,
        both: "",
        clickable: ""
      }, null, 8
      /* PROPS */
      , ["icon", "pack"])], 42
      /* CLASS, PROPS, HYDRATE_EVENTS */
      , ["aria-label"]), [[vue.vShow, !_ctx.showNext && !_ctx.disabled]]), vue.createVNode("div", {
        class: _ctx.listsClasses
      }, [!_ctx.isTypeMonth ? vue.createVNode(_component_o_select, vue.mergeProps({
        key: 0,
        modelValue: _ctx.focusedDateData.month,
        "onUpdate:modelValue": _cache[10] || (_cache[10] = $event => _ctx.focusedDateData.month = $event),
        disabled: _ctx.disabled,
        size: _ctx.size
      }, _ctx.selectListBind), {
        default: vue.withCtx(() => [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.listOfMonths, month => {
          return vue.openBlock(), vue.createBlock("option", {
            value: month.index,
            key: month.name,
            disabled: month.disabled
          }, vue.toDisplayString(month.name), 9
          /* TEXT, PROPS */
          , ["value", "disabled"]);
        }), 128
        /* KEYED_FRAGMENT */
        ))]),
        _: 1
      }, 16
      /* FULL_PROPS */
      , ["modelValue", "disabled", "size"]) : vue.createCommentVNode("v-if", true), vue.createVNode(_component_o_select, vue.mergeProps({
        modelValue: _ctx.focusedDateData.year,
        "onUpdate:modelValue": _cache[11] || (_cache[11] = $event => _ctx.focusedDateData.year = $event),
        disabled: _ctx.disabled,
        size: _ctx.size
      }, _ctx.selectListBind), {
        default: vue.withCtx(() => [(vue.openBlock(true), vue.createBlock(vue.Fragment, null, vue.renderList(_ctx.listOfYears, year => {
          return vue.openBlock(), vue.createBlock("option", {
            value: year,
            key: year
          }, vue.toDisplayString(year), 9
          /* TEXT, PROPS */
          , ["value"]);
        }), 128
        /* KEYED_FRAGMENT */
        ))]),
        _: 1
      }, 16
      /* FULL_PROPS */
      , ["modelValue", "disabled", "size"])], 2
      /* CLASS */
      )], 2
      /* CLASS */
      )])], 2
      /* CLASS */
      ), vue.renderSlot(_ctx.$slots, "table", {}, () => [!_ctx.isTypeMonth ? vue.createVNode(_component_o_datepicker_table, {
        key: 0,
        modelValue: _ctx.computedValue,
        "onUpdate:modelValue": _cache[12] || (_cache[12] = $event => _ctx.computedValue = $event),
        "day-names": _ctx.newDayNames,
        "month-names": _ctx.newMonthNames,
        "first-day-of-week": _ctx.firstDayOfWeek,
        "rules-for-first-week": _ctx.rulesForFirstWeek,
        "min-date": _ctx.minDate,
        "max-date": _ctx.maxDate,
        focused: _ctx.focusedDateData,
        disabled: _ctx.disabled,
        "unselectable-dates": _ctx.unselectableDates,
        "unselectable-days-of-week": _ctx.unselectableDaysOfWeek,
        "selectable-dates": _ctx.selectableDates,
        events: _ctx.events,
        indicators: _ctx.indicators,
        "date-creator": _ctx.dateCreator,
        "type-month": _ctx.isTypeMonth,
        "nearby-month-days": _ctx.nearbyMonthDays,
        "nearby-selectable-month-days": _ctx.nearbySelectableMonthDays,
        "show-week-number": _ctx.showWeekNumber,
        "week-number-clickable": _ctx.weekNumberClickable,
        range: _ctx.range,
        multiple: _ctx.multiple,
        "table-class": _ctx.tableClass,
        "table-head-class": _ctx.tableHeadClass,
        "table-head-cell-class": _ctx.tableHeadCellClass,
        "table-body-class": _ctx.tableBodyClass,
        "table-row-class": _ctx.tableRowClass,
        "table-cell-class": _ctx.tableCellClass,
        "table-cell-selected-class": _ctx.tableCellSelectedClass,
        "table-cell-first-selected-class": _ctx.tableCellFirstSelectedClass,
        "table-cell-invisible-class": _ctx.tableCellInvisibleClass,
        "table-cell-within-selected-class": _ctx.tableCellWithinSelectedClass,
        "table-cell-last-selected-class": _ctx.tableCellLastSelectedClass,
        "table-cell-first-hovered-class": _ctx.tableCellFirstHoveredClass,
        "table-cell-within-hovered-class": _ctx.tableCellWithinHoveredClass,
        "table-cell-last-hovered-class": _ctx.tableCellLastHoveredClass,
        "table-cell-today-class": _ctx.tableCellTodayClass,
        "table-cell-selectable-class": _ctx.tableCellSelectableClass,
        "table-cell-unselectable-class": _ctx.tableCellUnselectableClass,
        "table-cell-nearby-class": _ctx.tableCellNearbyClass,
        "table-cell-events-class": _ctx.tableCellEventsClass,
        "table-events-class": _ctx.tableEventsClass,
        "table-event-variant-class": _ctx.tableEventVariantClass,
        "table-event-class": _ctx.tableEventClass,
        "table-event-indicators-class": _ctx.tableEventIndicatorsClass,
        "onRange-start": _cache[13] || (_cache[13] = date => _ctx.$emit('range-start', date)),
        "onRange-end": _cache[14] || (_cache[14] = date => _ctx.$emit('range-end', date)),
        onClose: _cache[15] || (_cache[15] = $event => _ctx.togglePicker(false)),
        "onUpdate:focused": _cache[16] || (_cache[16] = $event => _ctx.focusedDateData = $event)
      }, null, 8
      /* PROPS */
      , ["modelValue", "day-names", "month-names", "first-day-of-week", "rules-for-first-week", "min-date", "max-date", "focused", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "type-month", "nearby-month-days", "nearby-selectable-month-days", "show-week-number", "week-number-clickable", "range", "multiple", "table-class", "table-head-class", "table-head-cell-class", "table-body-class", "table-row-class", "table-cell-class", "table-cell-selected-class", "table-cell-first-selected-class", "table-cell-invisible-class", "table-cell-within-selected-class", "table-cell-last-selected-class", "table-cell-first-hovered-class", "table-cell-within-hovered-class", "table-cell-last-hovered-class", "table-cell-today-class", "table-cell-selectable-class", "table-cell-unselectable-class", "table-cell-nearby-class", "table-cell-events-class", "table-events-class", "table-event-variant-class", "table-event-class", "table-event-indicators-class"]) : vue.createCommentVNode("v-if", true), _ctx.isTypeMonth ? vue.createVNode(_component_o_datepicker_month, {
        key: 1,
        modelValue: _ctx.computedValue,
        "onUpdate:modelValue": _cache[17] || (_cache[17] = $event => _ctx.computedValue = $event),
        "month-names": _ctx.newMonthNames,
        "min-date": _ctx.minDate,
        "max-date": _ctx.maxDate,
        focused: _ctx.focusedDateData,
        disabled: _ctx.disabled,
        "unselectable-dates": _ctx.unselectableDates,
        "unselectable-days-of-week": _ctx.unselectableDaysOfWeek,
        "selectable-dates": _ctx.selectableDates,
        events: _ctx.events,
        indicators: _ctx.indicators,
        "date-creator": _ctx.dateCreator,
        range: _ctx.range,
        multiple: _ctx.multiple,
        "month-class": _ctx.monthClass,
        "month-body-class": _ctx.monthBodyClass,
        "month-table-class": _ctx.monthTableClass,
        "month-cell-class": _ctx.monthCellClass,
        "month-cell-selected-class": _ctx.monthCellSelectedClass,
        "month-cell-first-selected-class": _ctx.monthCellFirstSelectedClass,
        "month-cell-within-selected-class": _ctx.monthCellWithinSelectedClass,
        "month-cell-last-selected-class": _ctx.monthCellLastSelectedClass,
        "month-cell-within-hovered-range-class": _ctx.monthCellWithinHoveredRangeClass,
        "month-cell-first-hovered-class": _ctx.monthCellFirstHoveredClass,
        "month-cell-within-hovered-class": _ctx.monthCellWithinHoveredClass,
        "month-cell-last-hovered-class": _ctx.monthCellLastHoveredClass,
        "month-cell-today-class": _ctx.monthCellTodayClass,
        "month-cell-selectable-class": _ctx.monthCellSelectableClass,
        "month-cell-unselectable-class": _ctx.monthCellUnselectableClass,
        "month-cell-events-class": _ctx.monthCellEventsClass,
        "onRange-start": _cache[18] || (_cache[18] = date => _ctx.$emit('range-start', date)),
        "onRange-end": _cache[19] || (_cache[19] = date => _ctx.$emit('range-end', date)),
        onClose: _cache[20] || (_cache[20] = $event => _ctx.togglePicker(false)),
        "onChange-focus": _ctx.changeFocus,
        "onUpdate:focused": _cache[21] || (_cache[21] = $event => _ctx.focusedDateData = $event)
      }, null, 8
      /* PROPS */
      , ["modelValue", "month-names", "min-date", "max-date", "focused", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "range", "multiple", "month-class", "month-body-class", "month-table-class", "month-cell-class", "month-cell-selected-class", "month-cell-first-selected-class", "month-cell-within-selected-class", "month-cell-last-selected-class", "month-cell-within-hovered-range-class", "month-cell-first-hovered-class", "month-cell-within-hovered-class", "month-cell-last-hovered-class", "month-cell-today-class", "month-cell-selectable-class", "month-cell-unselectable-class", "month-cell-events-class", "onChange-focus"]) : vue.createCommentVNode("v-if", true)]), _ctx.$slots.footer !== undefined ? (vue.openBlock(), vue.createBlock("footer", {
        key: 0,
        class: _ctx.footerClasses
      }, [vue.renderSlot(_ctx.$slots, "footer")], 2
      /* CLASS */
      )) : vue.createCommentVNode("v-if", true)]),
      _: 3
    }, 8
    /* PROPS */
    , ["item-class", "disabled"])]),
    _: 2
  }, [!_ctx.inline ? {
    name: "trigger",
    fn: vue.withCtx(() => [vue.renderSlot(_ctx.$slots, "trigger", {}, () => [vue.createVNode(_component_o_input, vue.mergeProps({
      ref: "input",
      autocomplete: "off",
      "model-value": _ctx.formattedValue,
      expanded: _ctx.expanded,
      placeholder: _ctx.placeholder,
      size: _ctx.size,
      icon: _ctx.icon,
      "icon-right": _ctx.iconRight,
      "icon-right-clickable": _ctx.iconRightClickable,
      "icon-pack": _ctx.iconPack,
      rounded: _ctx.rounded,
      disabled: _ctx.disabled,
      readonly: !_ctx.editable
    }, _ctx.inputBind, {
      "use-html5-validation": false,
      onClick: _ctx.onInputClick,
      "onIcon-right-click": _cache[1] || (_cache[1] = $event => _ctx.$emit('icon-right-click')),
      onKeyup: _cache[2] || (_cache[2] = vue.withKeys($event => _ctx.togglePicker(true), ["enter"])),
      onChange: _cache[3] || (_cache[3] = $event => _ctx.onChange($event.target.value)),
      onFocus: _ctx.handleOnFocus
    }), null, 16
    /* FULL_PROPS */
    , ["model-value", "expanded", "placeholder", "size", "icon", "icon-right", "icon-right-clickable", "icon-pack", "rounded", "disabled", "readonly", "onClick", "onFocus"])])])
  } : undefined]), 1040
  /* FULL_PROPS, DYNAMIC_SLOTS */
  , ["position", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "aria-modal", "append-to-body", "onActive-change"]) : vue.createVNode(_component_o_input, vue.mergeProps({
    key: 1,
    ref: "input",
    type: !_ctx.isTypeMonth ? 'date' : 'month',
    autocomplete: "off",
    value: _ctx.formatNative(_ctx.computedValue),
    placeholder: _ctx.placeholder,
    size: _ctx.size,
    icon: _ctx.icon,
    "icon-pack": _ctx.iconPack,
    rounded: _ctx.rounded,
    max: _ctx.formatNative(_ctx.maxDate),
    min: _ctx.formatNative(_ctx.minDate),
    disabled: _ctx.disabled,
    readonly: false
  }, _ctx.$attrs, {
    "use-html5-validation": false,
    onChange: _ctx.onChangeNativePicker,
    onFocus: _ctx.onFocus,
    onBlur: _ctx.onBlur
  }), null, 16
  /* FULL_PROPS */
  , ["type", "value", "placeholder", "size", "icon", "icon-pack", "rounded", "max", "min", "disabled", "onChange", "onFocus", "onBlur"])], 2
  /* CLASS */
  );
}

script$3.render = render$3;
script$3.__file = "src/components/datepicker/Datepicker.vue";

exports.script = script$3;
