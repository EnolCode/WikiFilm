import { defineComponent, openBlock, createBlock, renderSlot, resolveComponent, createVNode, createCommentVNode, toDisplayString, resolveDynamicComponent, mergeProps, withCtx, Transition, withDirectives, vShow } from 'vue';
import './helpers.mjs';
import './config.mjs';
import { B as BaseComponentMixin, b as registerComponent } from './plugins-ba5e2464.mjs';

/**
 * A simple menu
 * @displayName Menu
 * @style _menu.scss
 */
var script = defineComponent({
    name: 'OMenu',
    configField: 'menu',
    mixins: [BaseComponentMixin],
    props: {
        accordion: {
            type: Boolean,
            default: true
        },
        activable: {
            type: Boolean,
            default: true
        },
        rootClass: [String, Array, Function]
    },
    data() {
        return {
            menuItems: [],
        };
    },
    computed: {
        rootClasses() {
            return this.computedClass('rootClass', 'o-menu');
        },
    },
    methods: {
        registerMenuItem(item) {
            this.menuItems.push(item);
        },
        resetMenu(excludedItems = []) {
            this.menuItems.forEach((item) => {
                if (!excludedItems.includes(item))
                    item.reset();
            });
        },
    },
    provide() {
        return {
            registerMenuItem: this.registerMenuItem,
            resetMenu: this.resetMenu,
            accordion: () => this.accordion,
            activable: () => this.activable,
        };
    }
});

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("div", {
    class: _ctx.rootClasses
  }, [renderSlot(_ctx.$slots, "default")], 2
  /* CLASS */
  );
}

script.render = render;
script.__file = "src/components/menu/Menu.vue";

var script$1 = defineComponent({
    name: 'OMenuList',
    configField: 'menu',
    mixins: [BaseComponentMixin],
    props: {
        ariaRole: String,
        label: String,
        icon: String,
        iconPack: String,
        /**
         * Icon size, optional
         * @values small, medium, large
         */
        size: String,
        listClass: [String, Array, Function],
        listLabelClass: [String, Array, Function],
    },
    computed: {
        listClasses() {
            return this.computedClass('listClass', 'o-menu-list');
        },
        labelClasses() {
            return this.computedClass('listLabelClass', 'o-menu-label');
        },
        computedAriaRole() {
            return this.ariaRole === 'menu' ? this.ariaRole : null;
        }
    }
});

const _hoisted_1 = {
  key: 1
};
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");

  return openBlock(), createBlock("div", null, [_ctx.label || _ctx.$slots.label ? (openBlock(), createBlock("div", {
    key: 0,
    class: _ctx.labelClasses
  }, [_ctx.label && _ctx.icon ? createVNode(_component_o_icon, {
    key: 0,
    icon: _ctx.icon,
    pack: _ctx.iconPack,
    size: _ctx.size
  }, null, 8
  /* PROPS */
  , ["icon", "pack", "size"]) : createCommentVNode("v-if", true), _ctx.label ? (openBlock(), createBlock("span", _hoisted_1, toDisplayString(_ctx.label), 1
  /* TEXT */
  )) : renderSlot(_ctx.$slots, "label", {
    key: 2
  })], 2
  /* CLASS */
  )) : createCommentVNode("v-if", true), createVNode("ul", {
    class: _ctx.listClasses,
    role: _ctx.computedAriaRole
  }, [renderSlot(_ctx.$slots, "default")], 10
  /* CLASS, PROPS */
  , ["role"])]);
}

script$1.render = render$1;
script$1.__file = "src/components/menu/MenuList.vue";

var script$2 = defineComponent({
    name: 'OMenuItem',
    mixins: [BaseComponentMixin],
    configField: 'menu',
    inheritAttrs: false,
    props: {
        label: String,
        active: Boolean,
        expanded: Boolean,
        disabled: Boolean,
        iconPack: String,
        icon: String,
        animation: {
            type: String,
            default: 'slide'
        },
        tag: {
            type: String,
            default: 'a'
        },
        ariaRole: {
            type: String,
            default: ''
        },
        /**
         * Icon size, optional
         * @values small, medium, large
         */
        size: String,
        itemClass: [String, Array, Function],
        itemActiveClass: [String, Array, Function],
        itemDisabledClass: [String, Array, Function],
        itemIconTextClass: [String, Array, Function],
        itemSubmenuClass: [String, Array, Function],
        itemWrapperClass: [String, Array, Function],
    },
    data() {
        return {
            newActive: this.active,
            newExpanded: this.expanded
        };
    },
    computed: {
        ariaRoleMenu() {
            return this.ariaRole === 'menuitem' ? this.ariaRole : null;
        },
        itemClasses() {
            return {
                [this.computedClass('itemClass', 'o-menu-item')]: true,
                [this.computedClass('itemActiveClass', 'o-menu-item--active')]: this.newActive,
                [this.computedClass('itemDisabledClass', 'o-menu-item--disabled')]: this.disabled,
                [this.computedClass('itemIconTextClass', 'o-menu-item--icon-text')]: this.icon,
            };
        },
        submenuClasses() {
            return this.computedClass('itemSubmenuClass', 'o-menu-item__submenu');
        },
        wrapperClasses() {
            return this.computedClass('itemWrapperClass', 'o-menu-item__wrapper');
        },
    },
    watch: {
        active(value) {
            this.newActive = value;
        },
        expanded(value) {
            this.newExpanded = value;
        }
    },
    methods: {
        handleClick() {
            if (this.disabled)
                return;
            this.triggerReset();
            this.newExpanded = this.$props.expanded || !this.newExpanded;
            this.$emit('update:expanded', this.newExpanded);
            if (this.activable) {
                this.newActive = true;
                this.$emit('update:active', this.newActive);
            }
        },
        triggerReset(child) {
            // The point of this method is to collect references to the clicked item and any parent, this way we can skip resetting those elements.
            if (this.triggerParentReset) {
                this.triggerParentReset(this);
            }
            else if (this.resetMenu) {
                this.resetMenu([this, child]);
            }
        },
        reset() {
            if (!this.$parent.$data.isMenu || (this.$parent.$data.isMenu && this.accordion)) {
                this.newExpanded = false;
                this.$emit('update:expanded', this.newExpanded);
            }
            if (this.activable) {
                this.newActive = false;
                this.$emit('update:active', this.newActive);
            }
        },
    },
    mounted() {
        if (this.registerMenuItem) {
            this.registerMenuItem(this);
        }
    },
    provide() {
        return {
            triggerParentReset: this.triggerReset,
        };
    },
    inject: {
        registerMenuItem: { default: false },
        resetMenu: { default: false },
        triggerParentReset: { default: false },
        accordion: { default: false },
        activable: { default: false }
    }
});

const _hoisted_1$1 = {
  key: 1
};
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");

  return openBlock(), createBlock("li", {
    role: _ctx.ariaRoleMenu,
    class: _ctx.wrapperClasses
  }, [(openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), mergeProps(_ctx.$attrs, {
    class: _ctx.itemClasses,
    onClick: _cache[1] || (_cache[1] = $event => _ctx.handleClick())
  }), {
    default: withCtx(() => [_ctx.icon ? createVNode(_component_o_icon, {
      key: 0,
      icon: _ctx.icon,
      pack: _ctx.iconPack,
      size: _ctx.size
    }, null, 8
    /* PROPS */
    , ["icon", "pack", "size"]) : createCommentVNode("v-if", true), _ctx.label ? (openBlock(), createBlock("span", _hoisted_1$1, toDisplayString(_ctx.label), 1
    /* TEXT */
    )) : renderSlot(_ctx.$slots, "label", {
      key: 2,
      expanded: _ctx.newExpanded,
      active: _ctx.newActive
    })]),
    _: 1
  }, 16
  /* FULL_PROPS */
  , ["class"])), createCommentVNode(" sub menu items "), _ctx.$slots.default ? createVNode(Transition, {
    key: 0,
    name: _ctx.animation
  }, {
    default: withCtx(() => [withDirectives(createVNode("ul", {
      class: _ctx.submenuClasses
    }, [renderSlot(_ctx.$slots, "default")], 2
    /* CLASS */
    ), [[vShow, _ctx.newExpanded]])]),
    _: 3
  }, 8
  /* PROPS */
  , ["name"]) : createCommentVNode("v-if", true)], 10
  /* CLASS, PROPS */
  , ["role"]);
}

script$2.render = render$2;
script$2.__file = "src/components/menu/MenuItem.vue";

var index = {
    install(app) {
        registerComponent(app, script);
        registerComponent(app, script$1);
        registerComponent(app, script$2);
    }
};

export default index;
export { script as OMenu, script$2 as OMenuItem, script$1 as OMenuList };
